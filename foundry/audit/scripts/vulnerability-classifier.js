#!/usr/bin/env node

/**
 * VeriTix Vulnerability Classification System
 * 
 * This script processes security analysis results from multiple tools
 * and provides standardized vulnerability classification and reporting.
 */

const fs = require('fs');
const path = require('path');

// Vulnerability severity levels
const SEVERITY = {
  CRITICAL: 'CRITICAL',
  HIGH: 'HIGH', 
  MEDIUM: 'MEDIUM',
  LOW: 'LOW',
  INFO: 'INFO'
};

// Vulnerability categories
const CATEGORY = {
  REENTRANCY: 'REENTRANCY',
  ACCESS_CONTROL: 'ACCESS_CONTROL',
  ARITHMETIC: 'ARITHMETIC',
  DOS: 'DOS',
  ECONOMIC: 'ECONOMIC',
  GAS_OPTIMIZATION: 'GAS_OPTIMIZATION',
  STANDARDS_COMPLIANCE: 'STANDARDS_COMPLIANCE',
  EXTERNAL_CALLS: 'EXTERNAL_CALLS',
  STATE_MANAGEMENT: 'STATE_MANAGEMENT'
};

// Vulnerability classification rules
const CLASSIFICATION_RULES = {
  'reentrancy-eth': { severity: SEVERITY.CRITICAL, category: CATEGORY.REENTRANCY },
  'reentrancy-no-eth': { severity: SEVERITY.HIGH, category: CATEGORY.REENTRANCY },
  'reentrancy-benign': { severity: SEVERITY.MEDIUM, category: CATEGORY.REENTRANCY },
  'arbitrary-send-eth': { severity: SEVERITY.CRITICAL, category: CATEGORY.EXTERNAL_CALLS },
  'controlled-delegatecall': { severity: SEVERITY.CRITICAL, category: CATEGORY.ACCESS_CONTROL },
  'suicidal': { severity: SEVERITY.CRITICAL, category: CATEGORY.ACCESS_CONTROL },
  'unprotected-upgrade': { severity: SEVERITY.HIGH, category: CATEGORY.ACCESS_CONTROL },
  'tx-origin': { severity: SEVERITY.HIGH, category: CATEGORY.ACCESS_CONTROL },
  'missing-zero-check': { severity: SEVERITY.MEDIUM, category: CATEGORY.STATE_MANAGEMENT },
  'locked-ether': { severity: SEVERITY.MEDIUM, category: CATEGORY.ECONOMIC },
  'costly-loop': { severity: SEVERITY.LOW, category: CATEGORY.GAS_OPTIMIZATION },
  'cache-array-length': { severity: SEVERITY.INFO, category: CATEGORY.GAS_OPTIMIZATION },
  'constable-states': { severity: SEVERITY.INFO, category: CATEGORY.GAS_OPTIMIZATION },
  'external-function': { severity: SEVERITY.INFO, category: CATEGORY.GAS_OPTIMIZATION },
  'immutable-states': { severity: SEVERITY.INFO, category: CATEGORY.GAS_OPTIMIZATION }
};

// VeriTix-specific classification rules
const VERITIX_RULES = {
  // Payment flow vulnerabilities
  'buyTicket-reentrancy': { severity: SEVERITY.CRITICAL, category: CATEGORY.REENTRANCY },
  'refundTicket-reentrancy': { severity: SEVERITY.CRITICAL, category: CATEGORY.REENTRANCY },
  'batchBuyTickets-reentrancy': { severity: SEVERITY.HIGH, category: CATEGORY.REENTRANCY },
  
  // Access control issues
  'organizer-bypass': { severity: SEVERITY.CRITICAL, category: CATEGORY.ACCESS_CONTROL },
  'owner-bypass': { severity: SEVERITY.CRITICAL, category: CATEGORY.ACCESS_CONTROL },
  'event-manipulation': { severity: SEVERITY.HIGH, category: CATEGORY.ACCESS_CONTROL },
  
  // Economic attacks
  'price-manipulation': { severity: SEVERITY.HIGH, category: CATEGORY.ECONOMIC },
  'scalping-bypass': { severity: SEVERITY.MEDIUM, category: CATEGORY.ECONOMIC },
  'refund-exploitation': { severity: SEVERITY.HIGH, category: CATEGORY.ECONOMIC },
  
  // Gas optimization opportunities
  'batch-gas-optimization': { severity: SEVERITY.LOW, category: CATEGORY.GAS_OPTIMIZATION },
  'storage-optimization': { severity: SEVERITY.INFO, category: CATEGORY.GAS_OPTIMIZATION },
  'function-optimization': { severity: SEVERITY.INFO, category: CATEGORY.GAS_OPTIMIZATION }
};

class VulnerabilityClassifier {
  constructor() {
    this.findings = [];
    this.reports = {};
  }

  /**
   * Load and process Slither analysis results
   */
  loadSlitherReport(reportPath) {
    try {
      const slitherData = JSON.parse(fs.readFileSync(reportPath, 'utf8'));
      
      slitherData.results?.detectors?.forEach(detector => {
        const finding = this.classifySlitherFinding(detector);
        if (finding) {
          this.findings.push(finding);
        }
      });
      
      this.reports.slither = slitherData;
      console.log(`Loaded ${slitherData.results?.detectors?.length || 0} Slither findings`);
    } catch (error) {
      console.error(`Error loading Slither report: ${error.message}`);
    }
  }

  /**
   * Load and process Mythril analysis results
   */
  loadMythrilReport(reportPath) {
    try {
      const mythrilData = JSON.parse(fs.readFileSync(reportPath, 'utf8'));
      
      mythrilData.issues?.forEach(issue => {
        const finding = this.classifyMythrilFinding(issue);
        if (finding) {
          this.findings.push(finding);
        }
      });
      
      this.reports.mythril = mythrilData;
      console.log(`Loaded ${mythrilData.issues?.length || 0} Mythril findings`);
    } catch (error) {
      console.error(`Error loading Mythril report: ${error.message}`);
    }
  }

  /**
   * Classify Slither detector findings
   */
  classifySlitherFinding(detector) {
    const rule = CLASSIFICATION_RULES[detector.check] || VERITIX_RULES[detector.check];
    
    if (!rule) {
      // Default classification for unknown detectors
      return {
        id: `slither-${detector.check}-${Date.now()}`,
        tool: 'slither',
        title: detector.description || detector.check,
        severity: SEVERITY.MEDIUM,
        category: CATEGORY.STATE_MANAGEMENT,
        description: detector.description,
        impact: detector.impact || 'Unknown impact',
        confidence: detector.confidence || 'Medium',
        elements: detector.elements || [],
        source_mapping: detector.source_mapping,
        raw_data: detector
      };
    }

    return {
      id: `slither-${detector.check}-${Date.now()}`,
      tool: 'slither',
      title: detector.description || detector.check,
      severity: rule.severity,
      category: rule.category,
      description: detector.description,
      impact: detector.impact || this.getDefaultImpact(rule.severity),
      confidence: detector.confidence || 'Medium',
      elements: detector.elements || [],
      source_mapping: detector.source_mapping,
      raw_data: detector
    };
  }

  /**
   * Classify Mythril vulnerability findings
   */
  classifyMythrilFinding(issue) {
    const severity = this.mapMythrilSeverity(issue.severity);
    const category = this.mapMythrilCategory(issue.swc_id, issue.title);

    return {
      id: `mythril-${issue.swc_id}-${Date.now()}`,
      tool: 'mythril',
      title: issue.title,
      severity: severity,
      category: category,
      description: issue.description,
      impact: this.getDefaultImpact(severity),
      confidence: 'High', // Mythril findings are generally high confidence
      swc_id: issue.swc_id,
      source_mapping: {
        filename: issue.filename,
        lineno: issue.lineno
      },
      raw_data: issue
    };
  }

  /**
   * Map Mythril severity to our classification system
   */
  mapMythrilSeverity(mythrilSeverity) {
    const severityMap = {
      'High': SEVERITY.HIGH,
      'Medium': SEVERITY.MEDIUM,
      'Low': SEVERITY.LOW
    };
    return severityMap[mythrilSeverity] || SEVERITY.MEDIUM;
  }

  /**
   * Map Mythril categories based on SWC ID and title
   */
  mapMythrilCategory(swcId, title) {
    const categoryMap = {
      'SWC-107': CATEGORY.REENTRANCY,
      'SWC-115': CATEGORY.ACCESS_CONTROL,
      'SWC-104': CATEGORY.EXTERNAL_CALLS,
      'SWC-101': CATEGORY.ARITHMETIC,
      'SWC-113': CATEGORY.DOS,
      'SWC-128': CATEGORY.DOS
    };

    if (categoryMap[swcId]) {
      return categoryMap[swcId];
    }

    // Fallback to title-based classification
    const titleLower = title.toLowerCase();
    if (titleLower.includes('reentrancy')) return CATEGORY.REENTRANCY;
    if (titleLower.includes('access') || titleLower.includes('auth')) return CATEGORY.ACCESS_CONTROL;
    if (titleLower.includes('overflow') || titleLower.includes('underflow')) return CATEGORY.ARITHMETIC;
    if (titleLower.includes('gas') || titleLower.includes('dos')) return CATEGORY.DOS;
    
    return CATEGORY.STATE_MANAGEMENT;
  }

  /**
   * Get default impact description based on severity
   */
  getDefaultImpact(severity) {
    const impactMap = {
      [SEVERITY.CRITICAL]: 'Immediate fund loss or complete contract compromise possible',
      [SEVERITY.HIGH]: 'Significant security risk with potential for exploitation',
      [SEVERITY.MEDIUM]: 'Moderate risk that could lead to unexpected behavior',
      [SEVERITY.LOW]: 'Minor security concern or best practice violation',
      [SEVERITY.INFO]: 'Informational finding or optimization opportunity'
    };
    return impactMap[severity] || 'Impact assessment required';
  }

  /**
   * Calculate overall security score
   */
  calculateSecurityScore() {
    const severityWeights = {
      [SEVERITY.CRITICAL]: -50,
      [SEVERITY.HIGH]: -20,
      [SEVERITY.MEDIUM]: -10,
      [SEVERITY.LOW]: -5,
      [SEVERITY.INFO]: 0
    };

    let score = 100;
    const severityCounts = {};

    this.findings.forEach(finding => {
      score += severityWeights[finding.severity] || 0;
      severityCounts[finding.severity] = (severityCounts[finding.severity] || 0) + 1;
    });

    return {
      score: Math.max(0, score),
      breakdown: severityCounts,
      total_findings: this.findings.length,
      mainnet_ready: score >= 80 && (severityCounts[SEVERITY.CRITICAL] || 0) === 0
    };
  }

  /**
   * Generate comprehensive security report
   */
  generateReport() {
    const securityScore = this.calculateSecurityScore();
    
    const report = {
      metadata: {
        generated_at: new Date().toISOString(),
        version: '1.0.0',
        tools_used: Object.keys(this.reports)
      },
      security_assessment: {
        overall_score: securityScore.score,
        mainnet_ready: securityScore.mainnet_ready,
        total_findings: securityScore.total_findings,
        severity_breakdown: securityScore.breakdown
      },
      findings: this.findings.sort((a, b) => {
        const severityOrder = [SEVERITY.CRITICAL, SEVERITY.HIGH, SEVERITY.MEDIUM, SEVERITY.LOW, SEVERITY.INFO];
        return severityOrder.indexOf(a.severity) - severityOrder.indexOf(b.severity);
      }),
      recommendations: this.generateRecommendations(),
      raw_reports: this.reports
    };

    return report;
  }

  /**
   * Generate security recommendations based on findings
   */
  generateRecommendations() {
    const recommendations = [];
    const categoryCounts = {};

    this.findings.forEach(finding => {
      categoryCounts[finding.category] = (categoryCounts[finding.category] || 0) + 1;
    });

    // Generate category-specific recommendations
    if (categoryCounts[CATEGORY.REENTRANCY] > 0) {
      recommendations.push({
        priority: 'HIGH',
        category: CATEGORY.REENTRANCY,
        recommendation: 'Implement OpenZeppelin ReentrancyGuard on all functions with external calls',
        implementation: 'Add nonReentrant modifier to buyTicket(), refundTicket(), and batchBuyTickets()'
      });
    }

    if (categoryCounts[CATEGORY.ACCESS_CONTROL] > 0) {
      recommendations.push({
        priority: 'HIGH',
        category: CATEGORY.ACCESS_CONTROL,
        recommendation: 'Review and strengthen access control mechanisms',
        implementation: 'Validate all onlyOwner and organizer-only functions'
      });
    }

    if (categoryCounts[CATEGORY.GAS_OPTIMIZATION] > 2) {
      recommendations.push({
        priority: 'MEDIUM',
        category: CATEGORY.GAS_OPTIMIZATION,
        recommendation: 'Implement identified gas optimizations',
        implementation: 'Apply storage optimizations and function improvements'
      });
    }

    return recommendations;
  }

  /**
   * Save report to file
   */
  saveReport(outputPath) {
    const report = this.generateReport();
    fs.writeFileSync(outputPath, JSON.stringify(report, null, 2));
    console.log(`Security report saved to: ${outputPath}`);
    return report;
  }
}

// CLI interface
if (require.main === module) {
  const classifier = new VulnerabilityClassifier();
  
  // Load reports from standard locations
  const slitherReportPath = './audit/reports/slither/slither-report.json';
  const mythrilReportPath = './audit/reports/mythril/mythril-report.json';
  
  if (fs.existsSync(slitherReportPath)) {
    classifier.loadSlitherReport(slitherReportPath);
  }
  
  if (fs.existsSync(mythrilReportPath)) {
    classifier.loadMythrilReport(mythrilReportPath);
  }
  
  // Generate and save comprehensive report
  const outputPath = './audit/reports/security-assessment.json';
  const report = classifier.saveReport(outputPath);
  
  console.log('\n=== Security Assessment Summary ===');
  console.log(`Overall Score: ${report.security_assessment.overall_score}/100`);
  console.log(`Mainnet Ready: ${report.security_assessment.mainnet_ready ? 'YES' : 'NO'}`);
  console.log(`Total Findings: ${report.security_assessment.total_findings}`);
  console.log('\nSeverity Breakdown:');
  Object.entries(report.security_assessment.severity_breakdown).forEach(([severity, count]) => {
    console.log(`  ${severity}: ${count}`);
  });
}

module.exports = VulnerabilityClassifier;